<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-03-11T20:24:45.566075177"><title>Section 2 : Le tas | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"avec-le-mot-cl-new","level":0,"title":"Avec le mot-clé new","anchor":"#avec-le-mot-cl-new"},{"id":"avec-l-op-rateur-lors-de-l-initialisation-de-variables","level":0,"title":"Avec l\u0027opérateur \u0026 lors de l\u0027initialisation de variables","anchor":"#avec-l-op-rateur-lors-de-l-initialisation-de-variables"},{"id":"analyse-d-chappement","level":0,"title":"Analyse d\u0027échappement","anchor":"#analyse-d-chappement"},{"id":"adresse-sur-la-pile-vs-sur-le-tas","level":0,"title":"Adresse sur la pile vs. sur le tas","anchor":"#adresse-sur-la-pile-vs-sur-le-tas"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : Le tas | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="ch06s02-section-2-le-tas.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : Le tas | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "ch06s02-section-2-le-tas.html#webpage",
    "url": "ch06s02-section-2-le-tas.html",
    "name": "Section 2 : Le tas | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "/#website",
    "url": "/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="ch06s02-Section-2-Le-tas" data-main-title="Section 2 : Le tas" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="ch06-Gestion-de-la-memoire.md|Chapitre 6 : Gestion de la mémoire"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch06s02-Section-2-Le-tas" id="ch06s02-Section-2-Le-tas.md">Section 2 : Le tas</h1><p id="77f103fe_51">Le probl&egrave;me avec la m&eacute;moire allou&eacute;e sur la pile d'ex&eacute;cution est qu'&agrave; la fin de l'ex&eacute;cution de la fonction, la m&eacute;moire est lib&eacute;r&eacute;e avec le cadre d'ex&eacute;cution de la fonction. Donc une fonction peut partager de la m&eacute;moire avec les fonctions qu'elle appelle, en passant des pointeurs vers les variables &agrave; partager aux autres fonctions, et une fonction peut retourner une ou des valeurs &agrave; la fonction qui l'a appel&eacute;e, mais ces valeurs retourn&eacute;es seront copi&eacute;es lors du retour de fonction (donc, pas vraiment partag&eacute;es).</p><p id="77f103fe_52">Pour partager de la m&eacute;moire plus librement, sans avoir besoin de la copier &agrave; plusieurs reprises, et sans avoir besoin de se pr&eacute;occuper de son allocation sur la pile, on peut allouer de la m&eacute;moire sur le tas. La m&eacute;moire allou&eacute;e sur le tas est g&eacute;r&eacute;e diff&eacute;remment de la m&eacute;moire allou&eacute;e sur la pile, qui est directement li&eacute;e &agrave; la dur&eacute;e d'ex&eacute;cution d'une fonction.</p><p id="77f103fe_53">L'allocation de m&eacute;moire sur le tas (<span class="emphasis" id="77f103fe_54">heap</span>) est g&eacute;n&eacute;ralement g&eacute;r&eacute;e par le compilateur. Cela se fait principalement par l'interm&eacute;diaire du mot-cl&eacute; <code class="code" id="77f103fe_55">new</code> et l'op&eacute;rateur <code class="code" id="77f103fe_56">&amp;</code> lors de l'initialisation d'une variable.</p><section class="chapter"><h2 id="avec-le-mot-cl-new" data-toc="avec-le-mot-cl-new">Avec le mot-cl&eacute; new</h2><p id="77f103fe_57">En Go, <code class="code" id="77f103fe_58">new(T)</code> alloue de la m&eacute;moire sur le tas pour une nouvelle item de type <code class="code" id="77f103fe_59">T</code>, initialise &agrave; z&eacute;ro et renvoie un pointeur vers cet item. Voici un exemple :</p><div class="code-block" data-lang="go">
i := new(int)
*i = 3
fmt.Println(*i)  // Affiche &quot;3&quot;
</div><p id="77f103fe_61">Dans cet exemple, <code class="code" id="77f103fe_62">new(int)</code> alloue de la m&eacute;moire pour un nouvel <code class="code" id="77f103fe_63">int</code> sur le tas, initialis&eacute; &agrave; z&eacute;ro, et renvoie un pointeur vers cet <code class="code" id="77f103fe_64">int</code>. Ensuite, nous utilisons le <code class="code" id="77f103fe_65">*</code> pour d&eacute;r&eacute;f&eacute;rencer le pointeur et assigner la valeur <code class="code" id="77f103fe_66">3</code> &agrave; l' <code class="code" id="77f103fe_67">int</code> sur le tas.</p></section><section class="chapter"><h2 id="avec-l-op-rateur-lors-de-l-initialisation-de-variables" data-toc="avec-l-op-rateur-lors-de-l-initialisation-de-variables">Avec l'op&eacute;rateur &amp; lors de l'initialisation de variables</h2><p id="77f103fe_68">Cet op&eacute;rateur est g&eacute;n&eacute;ralement utilis&eacute; pour obtenir l'adresse d'une variable existante. Cependant, lorsqu'il est utilis&eacute; pendant l'initialisation d'une variable (par exemple, lors de l'initialisation d'une <code class="code" id="77f103fe_69">struct</code>), cela provoquera aussi l'allocation de m&eacute;moire sur le tas.</p><div class="code-block" data-lang="go">
type Person struct {
   Name string
   Age  int
}
   
p := &amp;Person{&quot;Alice&quot;, 30}
fmt.Println(p)  // Affiche l'adresse mémoire de la struct Person sur le tas
</div><p id="77f103fe_71">Dans cet exemple, <code class="code" id="77f103fe_72">&amp;Person{&quot;Alice&quot;, 30}</code> cr&eacute;e une nouvelle struct <code class="code" id="77f103fe_73">Person</code> avec les valeurs fournies, alloue de la m&eacute;moire pour celle-ci sur le tas, et renvoie un pointeur vers cette struct.</p><p id="77f103fe_74">Il est &agrave; noter que les d&eacute;tails de l'allocation de m&eacute;moire peuvent &ecirc;tre assez compliqu&eacute;s en pratique, car le compilateur Go utilise une technique appel&eacute;e &quot;analyse d'&eacute;chappement&quot; pour d&eacute;cider o&ugrave; une variable devrait &ecirc;tre allou&eacute;e. Il existe des cas o&ugrave; une variable pourrait &ecirc;tre allou&eacute;e sur la pile m&ecirc;me si vous avez utilis&eacute; <code class="code" id="77f103fe_75">new</code> ou <code class="code" id="77f103fe_76">&amp;</code> lors de l'initialisation.</p></section><section class="chapter"><h2 id="analyse-d-chappement" data-toc="analyse-d-chappement">Analyse d'&eacute;chappement</h2><p id="77f103fe_77"><span class="control" id="77f103fe_78">L'analyse d'&eacute;chappement</span> (ou <span class="emphasis" id="77f103fe_79">Escape Analysis</span> en anglais) est un processus effectu&eacute; par le compilateur pour d&eacute;terminer si une certaine variable peut &ecirc;tre allou&eacute;e sur la pile au lieu du tas.</p><p id="77f103fe_80">La logique principale derri&egrave;re l'analyse d'&eacute;chappement est la suivante : si la dur&eacute;e de vie d'une variable est limit&eacute;e &agrave; l'ex&eacute;cution d'une seule fonction, alors le compilateur peut d&eacute;cider d'allouer cette variable sur la pile plut&ocirc;t que sur le tas. Cela peut offrir un avantage de performance significatif, car l'acc&egrave;s &agrave; la pile est g&eacute;n&eacute;ralement plus rapide que l'acc&egrave;s &agrave; la m&eacute;moire du tas, et les objets de la pile ne n&eacute;cessitent pas de garbage collection.</p><p id="77f103fe_81">N&eacute;anmoins, si une variable est accessible (ou &laquo; s'&eacute;chappe &raquo;) en dehors de la fonction o&ugrave; elle a &eacute;t&eacute; d&eacute;finie (par exemple, si elle est renvoy&eacute;e par une fonction ou captur&eacute;e &agrave; l'int&eacute;rieur d'une fermeture), alors elle doit &ecirc;tre allou&eacute;e sur le tas.</p><p id="77f103fe_82">Par exemple, dans le code Go suivant:</p><div class="code-block" data-lang="go">
func foo() *Bar {
    b := Bar{}
    return &amp;b
}
</div><p id="77f103fe_84">La variable <code class="code" id="77f103fe_85">b</code> est allou&eacute;e sur le tas parce qu'elle est renvoy&eacute;e par la fonction <code class="code" id="77f103fe_86">foo</code> et pourrait donc &ecirc;tre utilis&eacute;e ailleurs, en dehors de la port&eacute;e de la fonction <code class="code" id="77f103fe_87">foo</code>. Si <code class="code" id="77f103fe_88">b</code> &eacute;tait allou&eacute;e sur la pile, elle serait d&eacute;truite d&egrave;s que <code class="code" id="77f103fe_89">foo</code> aurait termin&eacute; l'ex&eacute;cution, ce qui ne serait pas correct si une autre partie du code a besoin d'y acc&eacute;der plus tard.</p><p id="77f103fe_90">Le compilateur Go ex&eacute;cute l'analyse d'&eacute;chappement pour d&eacute;terminer si les variables doivent &ecirc;tre allou&eacute;es sur le tas ou sur la pile.</p></section><section class="chapter"><h2 id="adresse-sur-la-pile-vs-sur-le-tas" data-toc="adresse-sur-la-pile-vs-sur-le-tas">Adresse sur la pile vs. sur le tas</h2><p id="77f103fe_91">Voici un exemple de code qui montre comment allouer une struct <code class="code" id="77f103fe_92">Person</code> sur le tas et une sur la pile, puis imprime leur adresse pour comparaison :</p><div class="code-block" data-lang="go">
package main

import (
	&quot;fmt&quot;
)

type Person struct {
	Name string
	Age  int
}

func main() {
	// Allocation sur le tas
	pHeap := &amp;Person{&quot;Alice&quot;, 30}
	fmt.Printf(&quot;Address of person on heap: %p\n&quot;, pHeap)

	// Allocation sur la pile
	pStack := Person{&quot;Bob&quot;, 35}
	fmt.Printf(&quot;Address of person on stack: %p\n&quot;, &amp;pStack)
}
</div><p id="77f103fe_94">Dans ce code, <code class="code" id="77f103fe_95">pHeap</code> est un pointeur vers une instance de <code class="code" id="77f103fe_96">Person</code> qui est allou&eacute;e sur le tas, et <code class="code" id="77f103fe_97">pStack</code> est une instance de <code class="code" id="77f103fe_98">Person</code> qui est allou&eacute;e sur la pile. Les adresses de ces deux variables sont ensuite imprim&eacute;es pour comparaison. Vous remarquerez probablement que l'adresse de la variable sur le tas est significativement plus grande que celle de la variable sur la pile. Les adresses pr&eacute;cises varieront &agrave; chaque ex&eacute;cution du programme.</p></section><div class="last-modified">Last modified: 12 mars 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ch06s01-section-1-la-pile.html" class="navigation-links__prev">Section 1 : La pile d'ex&eacute;cution</a><a href="ch06s03-section-3-le-vidangeur.html" class="navigation-links__next">Section 3 : Le vidangeur</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>