<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-29T10:29:26.511568749"><title>Section 2 : M&eacute;thodes | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"est-ce-que-go-est-orient-objet","level":0,"title":"Est-ce que Go est orienté-objet ?","anchor":"#est-ce-que-go-est-orient-objet"},{"id":"comment-d-finir-une-m-thode","level":0,"title":"Comment définir une méthode","anchor":"#comment-d-finir-une-m-thode"},{"id":"comment-appeler-une-m-thode","level":0,"title":"Comment appeler une méthode","anchor":"#comment-appeler-une-m-thode"},{"id":"conversion-pour-l-impression","level":0,"title":"Conversion pour l\u0027impression","anchor":"#conversion-pour-l-impression"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : M&eacute;thodes | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/ch05s02-section-2-methodes.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : M&eacute;thodes | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/ch05s02-section-2-methodes.html#webpage",
    "url": "writerside-documentation/ch05s02-section-2-methodes.html",
    "name": "Section 2 : M&eacute;thodes | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="ch05s02-Section-2-Methodes" data-main-title="Section 2 : Méthodes" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="ch05-Chapitre-5-Les-structures.md|Chapitre 5 : Les structures"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch05s02-Section-2-Methodes" id="ch05s02-Section-2-Methodes.md">Section 2 : Méthodes</h1><p id="b33l13_72">Voici le contenu du fichier <code class="code" id="b33l13_73">point.go</code>, qui contient le m&ecirc;me d&eacute;finition de la structure <code class="code" id="b33l13_74">Point</code> et le m&ecirc;me constructeur que dans la section pr&eacute;c&eacute;dente, mais qui contient en plus quelques m&eacute;thodes d&eacute;finies sur <code class="code" id="b33l13_75">Point</code>.</p><p id="b33l13_76"><a href="https://github.com/profdenis/native1/tree/master/chap5/point.go" id="b33l13_77" data-external="true" rel="noopener noreferrer">point.go sur Github</a></p><div class="code-block" data-lang="go">
package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
)

type Point struct {
	X float64
	Y float64
}

func NewPoint(x float64, y float64) *Point {
	return &amp;Point{X: x, Y: y}
}

// String convertir le Point en String pour implémenter l'interface Stringer
func (p *Point) String() string {
	return fmt.Sprintf(&quot;Point(%f, %f)&quot;, p.X, p.Y)
}

// Add additionne 2 points et retourne le résultat dans un 3e point
func (p *Point) Add(other *Point) *Point {
	return &amp;Point{p.X + other.X, p.Y + other.Y}
}

// Subtract soustrait 2 point et retourne le résultat dans un 3e point
func (p *Point) Subtract(other *Point) *Point {
	return &amp;Point{p.X - other.X, p.Y - other.Y}
}

// Distance calcule et retourne la distance Euclidienne entre 2 point
func (p *Point) Distance(other *Point) float64 {
	return math.Sqrt(math.Pow(other.X-p.X, 2) + math.Pow(other.Y-p.Y, 2))
}

// Scale mise à l'échelle d'un Point par un facteur et retourne le résultat dans un nouveau point
func (p *Point) Scale(factor float64) *Point {
	return &amp;Point{p.X * factor, p.Y * factor}
}
</div><p id="b33l13_79">Les m&eacute;thodes sont un type de fonctions particuli&egrave;res : ce sont des fonctions d&eacute;finies sur des structures. C'est le m&ecirc;me concept que les m&eacute;thodes dans d'autres langages comme Java et C#, mais d&eacute;finies sur des structures &agrave; la place des classes.</p><section class="chapter"><h2 id="est-ce-que-go-est-orient-objet" data-toc="est-ce-que-go-est-orient-objet">Est-ce que Go est orient&eacute;-objet ?</h2><p id="b33l13_80">Go n'est pas un langage orient&eacute;-objet dans le m&ecirc;me sens que Java et C# le sont parce que Go ne supporte pas l'h&eacute;ritage entre classes (ou structures), mais &agrave; part pour cette diff&eacute;rence, les structures et les classes sont des concepts tr&egrave;s similaires. Go supporte les interfaces et la composition de structures et d'interfaces en plus des m&eacute;thodes, mais pas l'h&eacute;ritage entre classes et le polymorphisme, donc c'est pourquoi Go n'est pas consid&eacute;r&eacute; comme &eacute;tant orient&eacute;-objet par certains qui consid&egrave;rent l'h&eacute;ritage entre classes et le polymorphisme comme &eacute;tant obligatoire pour qu' un langage soit qualifi&eacute; d'orient&eacute;-objet. Il n'existe aucune d&eacute;finition exacte de ce qu'est un langage orient&eacute;-objet, donc d&eacute;pendamment de la d&eacute;finition utilis&eacute;e, Go peut &ecirc;tre consid&eacute;r&eacute; comme orient&eacute;-objet ou non.</p></section><section class="chapter"><h2 id="comment-d-finir-une-m-thode" data-toc="comment-d-finir-une-m-thode">Comment d&eacute;finir une m&eacute;thode</h2><p id="b33l13_81">Comme pr&eacute;sent&eacute; dans l'exemple plus haut, les m&eacute;thodes sont d&eacute;finies en dehors de la d&eacute;finition de la structure. Une m&eacute;thode est une fonction avec un &eacute;l&eacute;ment de plus : un <span class="emphasis" id="b33l13_82">receveur</span> est ajout&eacute; entre le mot <code class="code" id="b33l13_83">func</code> et le nom de la fonction. Le receveur d&eacute;fini sur quel type de structure la m&eacute;thode peut &ecirc;tre appel&eacute;e. Le receveur peut &ecirc;tre de type valeur ou pointeur. Le receveur est comme un param&egrave;tre suppl&eacute;mentaire sur une fonction, donc les m&ecirc;mes r&egrave;gles s'appliquent au receveur qu'aux autres param&egrave;tres d'une fonction :</p><ul class="list _bullet" id="b33l13_84"><li class="list__item" id="b33l13_85"><p>si le receveur est de type valeur, alors le contenu de la structure sur laquelle la m&eacute;thode est appel&eacute;e sera copi&eacute;e dans une variable locale temporaire pour l'ex&eacute;cution de la m&eacute;thode.</p></li><li class="list__item" id="b33l13_86"><p>si le receveur est un pointeur, alors le contenu de la structure ne sera pas copi&eacute; parce que l'adresse de la structure sera donn&eacute;e &agrave; la m&eacute;thode, donc les modifications apport&eacute;es &agrave; la structure dans la m&eacute;thode seront visibles &agrave; l'ext&eacute;rieur de la m&eacute;thode.</p></li></ul></section><section class="chapter"><h2 id="comment-appeler-une-m-thode" data-toc="comment-appeler-une-m-thode">Comment appeler une m&eacute;thode</h2><p id="b33l13_87">Dans cet exemple, on commence par cr&eacute;er 2 points avec le constructeur, et ensuite, on appelle la m&eacute;thode <code class="code" id="b33l13_88">Add</code> sur le premier point, en donnant le 2e point en argument. Pour appeler une m&eacute;thode sur une structure, il faut utiliser le <code class="code" id="b33l13_89">.</code> directement pr&eacute;c&eacute;d&eacute; d'une structure ou d'un pointeur vers une structure, suivi du nom de la m&eacute;thode et de ses arguments.</p><div class="code-block" data-lang="go">
p1 := NewPoint(1, 2)
p2 := NewPoint(3, 4)
fmt.Println(p1)
fmt.Println(p2)

p3 := p1.Add(p2)
fmt.Println(p3)
</div><p id="b33l13_91">Sortie :</p><div class="code-block" data-lang="go">
Point(1.000000, 2.000000)
Point(3.000000, 4.000000)
Point(4.000000, 6.000000)
</div></section><section class="chapter"><h2 id="conversion-pour-l-impression" data-toc="conversion-pour-l-impression">Conversion pour l'impression</h2><p id="b33l13_93">La m&eacute;thode <code class="code" id="b33l13_94">String</code> d&eacute;finie sur la structure <code class="code" id="b33l13_95">Point</code> est sp&eacute;ciale car elle permet la conversion de la structure en cha&icirc;ne de caract&egrave;res pour la sortie, sur le terminal dans cet exemple-ci. Quand on appelle <code class="code" id="b33l13_96">fmt.Println</code> (ou d'autres fonctions d'impression) sur un point, si la m&eacute;thode <code class="code" id="b33l13_97">String()</code> qui retourne une <code class="code" id="b33l13_98">string</code> est d&eacute;finie, alors elle sera utilis&eacute;e pour la conversion du point en cha&icirc;ne de caract&egrave;res. Cette fonction est d&eacute;finie dans l'interface <code class="code" id="b33l13_99">Stringer</code>. En Java, la m&eacute;thode <code class="code" id="b33l13_100">toString</code> joue le m&ecirc;me r&ocirc;le.</p><p id="b33l13_101">Si cette m&eacute;thode n'est pas d&eacute;finie, alors la sortie sera :</p><div class="code-block" data-lang="go">
&amp;{1 2}
&amp;{3 4}
&amp;{4 6}
</div><p id="b33l13_103">Par d&eacute;fault, si la m&eacute;thode String n'est pas d&eacute;finie, alors la sortie commencera par <code class="code" id="b33l13_104">&amp;</code> si on a un pointeur vers une structure, et entre accolades <code class="code" id="b33l13_105">{}</code>, on aura la valeur de tous les champs s&eacute;par&eacute;s par des espaces.</p></section><div class="last-modified">Last modified: 29 avril 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ch05s01-section-1-valeur-vs-pointeur.html" class="navigation-links__prev">Section 1 : Valeur vs. pointeur</a><a href="ch05s03-section-3-serialisation-des-structures.html" class="navigation-links__next">Section 3 : S&eacute;rialisation des structures</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>