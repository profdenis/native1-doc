<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-29T10:29:26.560606972"><title>Section 2 : Les listes cha&icirc;n&eacute;es | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"comparaison-des-listes-cha-n-es-aux-tableaux-de-taille-fixe-et-aux-tableaux-dynamiques","level":0,"title":"Comparaison des listes chaînées aux tableaux de taille fixe et aux tableaux dynamiques","anchor":"#comparaison-des-listes-cha-n-es-aux-tableaux-de-taille-fixe-et-aux-tableaux-dynamiques"},{"id":"code","level":0,"title":"Code","anchor":"#code"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : Les listes cha&icirc;n&eacute;es | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/ch07s02-section-2-les-listes-chainees.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : Les listes cha&icirc;n&eacute;es | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/ch07s02-section-2-les-listes-chainees.html#webpage",
    "url": "writerside-documentation/ch07s02-section-2-les-listes-chainees.html",
    "name": "Section 2 : Les listes cha&icirc;n&eacute;es | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="ch07s02-Section-2-Les-listes-chainees" data-main-title="Section 2 : Les listes chaînées" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="ch07-Chapitre-7-Structures-de-donnees.md|Chapitre 7 : Structures de données"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch07s02-Section-2-Les-listes-chainees" id="ch07s02-Section-2-Les-listes-chainees.md">Section 2 : Les listes chaînées</h1><p id="bz5h75_464">Une liste cha&icirc;n&eacute;e est une structure de donn&eacute;es lin&eacute;aire compos&eacute;e de n&oelig;uds qui contiennent des donn&eacute;es et un pointeur, qui pointe vers le prochain n&oelig;ud dans la s&eacute;quence. Si le pointeur d'un n&oelig;ud pointe vers <code class="code" id="bz5h75_465">nil</code> (ou <code class="code" id="bz5h75_466">null</code>), cela signifie qu'il s'agitdu dernier n&oelig;ud de la liste.</p><p id="bz5h75_467">Une liste cha&icirc;n&eacute;e a plusieurs utilisations :</p><ol class="list _decimal" id="bz5h75_468" type="1"><li class="list__item" id="bz5h75_469"><p id="bz5h75_470"><span class="control" id="bz5h75_471">Gestion de la m&eacute;moire :</span> Contrairement aux tableaux, les listes cha&icirc;n&eacute;es ne sont pas stock&eacute;es dans des blocs de m&eacute;moire contigus. Cela les rend particuli&egrave;rement utiles lorsque vous ne savez pas combien d'&eacute;l&eacute;ments seront dans la liste et que vous avez besoin d'ajouter ou de supprimer des &eacute;l&eacute;ments dynamiquement.</p></li><li class="list__item" id="bz5h75_472"><p id="bz5h75_473"><span class="control" id="bz5h75_474">Ajout/Suppression efficace des &eacute;l&eacute;ments :</span> Dans une liste cha&icirc;n&eacute;e, ajouter ou supprimer un &eacute;l&eacute;ment en t&ecirc;te de liste (ou possiblement &agrave; la fin de la liste) se fait en temps constant, ind&eacute;pendamment de la taille de la liste.</p></li><li class="list__item" id="bz5h75_475"><p id="bz5h75_476"><span class="control" id="bz5h75_477">Impl&eacute;mentation d'abstractions de donn&eacute;es de haut niveau :</span> Les listes cha&icirc;n&eacute;es peuvent &ecirc;tre utilis&eacute;es pour impl&eacute;menter des structures de donn&eacute;es plus complexes comme des piles, des files d'attente, et des tables de hachage.</p></li></ol><p id="bz5h75_478">Il est important de noter que les listes cha&icirc;n&eacute;es ont &eacute;galement leurs inconv&eacute;nients. Par exemple, contrairement aux tableaux, l'acc&egrave;s &agrave; un &eacute;l&eacute;ment sp&eacute;cifique d'une liste cha&icirc;n&eacute;e n&eacute;cessite g&eacute;n&eacute;ralement de traverser la liste depuis le d&eacute;but, ce qui peut &ecirc;tre lent pour de grandes listes.</p><section class="chapter"><h2 id="comparaison-des-listes-cha-n-es-aux-tableaux-de-taille-fixe-et-aux-tableaux-dynamiques" data-toc="comparaison-des-listes-cha-n-es-aux-tableaux-de-taille-fixe-et-aux-tableaux-dynamiques">Comparaison des listes cha&icirc;n&eacute;es aux tableaux de taille fixe et aux tableaux dynamiques</h2><ol class="list _decimal" id="bz5h75_479" type="1"><li class="list__item" id="bz5h75_480"><p id="bz5h75_481"><span class="control" id="bz5h75_482">Tableaux de taille fixe :</span></p><ul class="list _bullet" id="bz5h75_483"><li class="list__item" id="bz5h75_484"><p><span class="emphasis" id="bz5h75_485">Utilisation</span>: Les tableaux de taille fixe sont utiles lorsque la taille des donn&eacute;es est connue &agrave; l'avance et reste constante.</p></li><li class="list__item" id="bz5h75_486"><p><span class="emphasis" id="bz5h75_487">Performance</span>: L'acc&egrave;s &agrave; un &eacute;l&eacute;ment sp&eacute;cifique du tableau se fait en temps constant. C'est tr&egrave;s rapide, car chaque &eacute;l&eacute;ment est stock&eacute; &agrave; un emplacement contigu en m&eacute;moire. Cependant, l'ajout ou la suppression d'&eacute;l&eacute;ments peut n&eacute;cessiter de d&eacute;placer plusieurs &eacute;l&eacute;ments, ce qui peut prendre beaucoup de temps pour de grands tableaux.</p></li></ul></li><li class="list__item" id="bz5h75_488"><p id="bz5h75_489"><span class="control" id="bz5h75_490">Tableaux dynamiques (par exemple, des slices en Go ou des vecteurs en C++):</span></p><ul class="list _bullet" id="bz5h75_491"><li class="list__item" id="bz5h75_492"><p><span class="emphasis" id="bz5h75_493">Utilisation</span>: Les tableaux dynamiques sont utiles lorsque les donn&eacute;es changent dynamiquement en taille. Ils ajustent leur taille en allouant automatiquement de la nouvelle m&eacute;moire lors de l'ajout d'&eacute;l&eacute;ments.</p></li><li class="list__item" id="bz5h75_494"><p><span class="emphasis" id="bz5h75_495">Performance</span>: Comme les tableaux &agrave; taille fixe, l'acc&egrave;s &agrave; un &eacute;l&eacute;ment sp&eacute;cifique dans un tableau dynamique est &eacute;galement en temps constant. L'ajout d'&eacute;l&eacute;ments &agrave; la fin du tableau est g&eacute;n&eacute;ralement rapide, mais si la capacit&eacute; du tableau est d&eacute;pass&eacute;e, une nouvelle m&eacute;moire doit &ecirc;tre allou&eacute;e, ce qui peut prendre du temps. De m&ecirc;me, l'ajout ou la suppression d'&eacute;l&eacute;ments au milieu du tableau peut n&eacute;cessiter de d&eacute;placer plusieurs &eacute;l&eacute;ments.</p></li></ul></li><li class="list__item" id="bz5h75_496"><p id="bz5h75_497"><span class="control" id="bz5h75_498">Listes cha&icirc;n&eacute;es :</span></p><ul class="list _bullet" id="bz5h75_499"><li class="list__item" id="bz5h75_500"><p><span class="emphasis" id="bz5h75_501">Utilisation</span>: Les listes cha&icirc;n&eacute;es sont utiles lorsque les donn&eacute;es doivent &ecirc;tre ins&eacute;r&eacute;es ou supprim&eacute;es fr&eacute;quemment. Les listes cha&icirc;n&eacute;es sont &eacute;galement utiles pour impl&eacute;menter d'autres structures de donn&eacute;es comme les piles et les files d'attente.</p></li><li class="list__item" id="bz5h75_502"><p><span class="emphasis" id="bz5h75_503">Performance</span>: L'ajout et la suppression d'&eacute;l&eacute;ments au d&eacute;but ou &agrave; la fin de la liste se fait en temps constant, sans n&eacute;cessit&eacute; de d&eacute;placer d'autres &eacute;l&eacute;ments. Cependant, l'acc&egrave;s &agrave; un &eacute;l&eacute;ment sp&eacute;cifique dans une liste cha&icirc;n&eacute;e n&eacute;cessite de traverser la liste depuis le d&eacute;but, ce qui peut &ecirc;tre lent pour de grandes listes. De plus, contrairement aux tableaux, les listes cha&icirc;n&eacute;es n&eacute;cessitent un espace m&eacute;moire suppl&eacute;mentaire pour stocker les pointeurs vers les &eacute;l&eacute;ments suivants.</p></li></ul></li></ol><p id="bz5h75_504">En r&eacute;sum&eacute;, le choix entre un tableau (fixe ou dynamique) et une liste cha&icirc;n&eacute;e d&eacute;pend largement des sp&eacute;cificit&eacute;s de l'usage auquel la structure de donn&eacute;es est destin&eacute;e.</p></section><section class="chapter"><h2 id="code" data-toc="code">Code</h2><p id="bz5h75_505"><a href="https://github.com/profdenis/native1/tree/master/chap7/list" id="bz5h75_506" data-external="true" rel="noopener noreferrer">Code listes native1</a></p><p id="bz5h75_507">Dans ce code Go, une impl&eacute;mentation d'une liste simplement cha&icirc;n&eacute;e est fournie.</p><p id="bz5h75_508">Il y a deux structures d&eacute;finies : <code class="code" id="bz5h75_509">intNode</code> et <code class="code" id="bz5h75_510">IntList</code>. <code class="code" id="bz5h75_511">intNode</code> est la structure de base, repr&eacute;sentant un n&oelig;ud dans la liste, qui contient une valeur enti&egrave;re et a un attribut <code class="code" id="bz5h75_512">next</code> qui pointe vers le n&oelig;ud suivant dans la liste. <code class="code" id="bz5h75_513">Intlist</code> repr&eacute;sente la liste elle-m&ecirc;me qui stocke les n&oelig;uds de d&eacute;part et de fin (pointeurs sur <code class="code" id="bz5h75_514">intNode</code>), et la taille (nombre d'&eacute;l&eacute;ments) de la liste.</p><p id="bz5h75_515">La fonction <code class="code" id="bz5h75_516">NewIntList</code> cr&eacute;e une nouvelle liste d'entiers avec les &eacute;l&eacute;ments donn&eacute;s. Elle utilise des param&egrave;tres variadiques, permettant d'inputer plusieurs entiers sans avoir besoin de les emballer dans un slice. Les <code class="code" id="bz5h75_517">...int</code> dans la signature de la fonction d&eacute;notent ce param&egrave;tre variadique.</p><p id="bz5h75_518">Les fonctions <code class="code" id="bz5h75_519">AddStart</code> et <code class="code" id="bz5h75_520">AddEnd</code> sont des m&eacute;thodes qui permettent d'ajouter des &eacute;l&eacute;ments au d&eacute;but et &agrave; la fin de la liste respectivement.</p><p id="bz5h75_521"><code class="code" id="bz5h75_522">Insert</code> permet d'ins&eacute;rer un &eacute;l&eacute;ment &agrave; une position particuli&egrave;re dans la liste. Une erreur est renvoy&eacute;e si la position est invalide.</p><p id="bz5h75_523">La fonction <code class="code" id="bz5h75_524">IsEmpty</code> v&eacute;rifie si la liste est vide en v&eacute;rifiant si le n&oelig;ud de d&eacute;part est nul.</p><p id="bz5h75_525">La fonction <code class="code" id="bz5h75_526">Size</code> renvoie la taille de la liste.</p><p id="bz5h75_527">La m&eacute;thode <code class="code" id="bz5h75_528">String</code> fournit une repr&eacute;sentation en cha&icirc;ne de la liste. Elle utilise <code class="code" id="bz5h75_529">strings.Builder</code> pour concat&eacute;ner efficacement les cha&icirc;nes.</p><p id="bz5h75_530">Les m&eacute;thodes <code class="code" id="bz5h75_531">RemoveStart</code> et <code class="code" id="bz5h75_532">RemoveEnd</code> suppriment le premier et le dernier &eacute;l&eacute;ment de la liste et les renvoient. Dans le cas o&ugrave; il n'y a pas d'&eacute;l&eacute;ments &agrave; supprimer, elles renvoient une erreur.</p><p id="bz5h75_533">La m&eacute;thode <code class="code" id="bz5h75_534">Remove</code> supprime un &eacute;l&eacute;ment &agrave; une position particuli&egrave;re. Comme <code class="code" id="bz5h75_535">Insert</code>, elle renvoie une erreur si la position est invalide.</p><p id="bz5h75_536">Il y a aussi plusieurs tests fournis pour garantir le bon fonctionnement des diff&eacute;rentes m&eacute;thodes. Ces tests utilisent le package <code class="code" id="bz5h75_537">testing</code> de Go pour ex&eacute;cuter et v&eacute;rifier les tests.</p><section class="chapter"><h3 id="isempty" data-toc="isempty"><code class="code" id="bz5h75_539">IsEmpty</code></h3><p id="bz5h75_540">V&eacute;rifie si la liste est vide ou non.</p><div class="code-block" data-lang="go">
func (list *IntList) IsEmpty() bool {
	return list.start == nil
}
</div><p id="bz5h75_542">Si la liste ne contient aucun &eacute;l&eacute;ment, alors elle ne contient aucun noeud, donc <code class="code" id="bz5h75_543">list.start</code> ne peut pointer vers un noeud de la liste puisqu'il y en a aucun, et on n'a pas le choix de faire pointer <code class="code" id="bz5h75_544">list.start</code> vers <code class="code" id="bz5h75_545">nil</code>.</p></section><section class="chapter"><h3 id="addstart" data-toc="addstart"><code class="code" id="bz5h75_547">AddStart</code></h3><p id="bz5h75_548">Ajoute au d&eacute;but de la liste.</p><p id="bz5h75_549">Voici une explication de la m&eacute;thode <code class="code" id="bz5h75_550">AddStart</code>:</p><ol class="list _decimal" id="bz5h75_551" type="1"><li class="list__item" id="bz5h75_552"><p>Un nouveau <code class="code" id="bz5h75_553">intNode</code> est cr&eacute;&eacute; avec <code class="code" id="bz5h75_554">element</code> comme valeur et le d&eacute;but existant de la liste comme noeud <code class="code" id="bz5h75_555">next</code>.</p></li><li class="list__item" id="bz5h75_556"><p>Le <code class="code" id="bz5h75_557">start</code> de <code class="code" id="bz5h75_558">IntList</code> est mis &agrave; jour vers ce nouveau noeud.</p></li><li class="list__item" id="bz5h75_559"><p>La taille de <code class="code" id="bz5h75_560">IntList</code> est augment&eacute;e de 1.</p></li></ol><div class="code-block" data-lang="go">
func (list *IntList) AddStart(element int) {
	newStart := &amp;intNode{value: element, next: list.start} // Etape 1
	list.start = newStart // Etape 2
	list.size++ // Etape 3
}
</div><p id="bz5h75_562">En essence, <code class="code" id="bz5h75_563">AddStart</code> ajoute un &eacute;l&eacute;ment au d&eacute;but de la liste, repoussant les &eacute;l&eacute;ments actuels une position en arri&egrave;re.</p><p id="bz5h75_564">Votre cas de test associ&eacute; <code class="code" id="bz5h75_565">TestIntList_AddStart</code> confirme ce comportement. Il cr&eacute;e des listes avec des entr&eacute;es fournies, puis appelle <code class="code" id="bz5h75_566">AddStart</code> avec un &eacute;l&eacute;ment de test, et v&eacute;rifie que la liste r&eacute;sultante est celle attendue. Par exemple, dans le cas <code class="code" id="bz5h75_567">TestIntList_AddStart_WithNonEmptyList</code>, une liste est cr&eacute;&eacute;e avec les &eacute;l&eacute;ments (2, 3, 4), puis <code class="code" id="bz5h75_568">AddStart</code> est appel&eacute;e avec <code class="code" id="bz5h75_569">1</code>. La liste attendue apr&egrave;s cette op&eacute;ration est (1, 2, 3, 4), ce qui signifie que <code class="code" id="bz5h75_570">1</code> a &eacute;t&eacute; ajout&eacute; avec succ&egrave;s au d&eacute;but.</p></section><section class="chapter"><h3 id="addend" data-toc="addend"><code class="code" id="bz5h75_572">AddEnd</code></h3><p id="bz5h75_573">Ajoute &agrave; la fin de la liste.</p><ul class="list _bullet" id="bz5h75_574"><li class="list__item" id="bz5h75_575"><p>La fonction <code class="code" id="bz5h75_576">AddEnd</code> correspond &agrave; une structure de donn&eacute;es de liste cha&icirc;n&eacute;e. Elle prend un entier comme argument et l'ajoute comme un n&oelig;ud &agrave; la fin de la liste.</p></li><li class="list__item" id="bz5h75_577"><p>Le <code class="code" id="bz5h75_578">struct IntList</code> a trois champs : <code class="code" id="bz5h75_579">start</code>, <code class="code" id="bz5h75_580">end</code> et <code class="code" id="bz5h75_581">size</code>. <code class="code" id="bz5h75_582">start</code> et <code class="code" id="bz5h75_583">end</code> sont des pointeurs vers le premier et le dernier n&oelig;uds de la liste respectivement, tandis que <code class="code" id="bz5h75_584">size</code> repr&eacute;sente le nombre d'&eacute;l&eacute;ments dans la liste.</p></li><li class="list__item" id="bz5h75_585"><p>La m&eacute;thode commence par v&eacute;rifier si <code class="code" id="bz5h75_586">list.start</code> est <code class="code" id="bz5h75_587">nil</code>. Si c'est le cas, cela signifie que la liste est vide. Dans ce cas, elle cr&eacute;e un nouveau n&oelig;ud dont la <code class="code" id="bz5h75_588">value</code> est &eacute;gale &agrave; <code class="code" id="bz5h75_589">element</code>, et les pointeurs <code class="code" id="bz5h75_590">start</code> et <code class="code" id="bz5h75_591">end</code> de la liste pointent vers ce seul n&oelig;ud.</p></li><li class="list__item" id="bz5h75_592"><p>Si la liste n'est pas vide (<code class="code" id="bz5h75_593">list.start</code> n'est pas <code class="code" id="bz5h75_594">nil</code>), elle cr&eacute;e un nouveau n&oelig;ud dont la <code class="code" id="bz5h75_595">value</code> est <code class="code" id="bz5h75_596">element</code> et <code class="code" id="bz5h75_597">next</code> est <code class="code" id="bz5h75_598">nil</code> par d&eacute;faut. Le champ <code class="code" id="bz5h75_599">next</code> du n&oelig;ud <code class="code" id="bz5h75_600">end</code> actuel est mis &agrave; jour pour pointer vers ce nouveau n&oelig;ud. Ensuite, <code class="code" id="bz5h75_601">list.end</code> est r&eacute;affect&eacute; &agrave; ce nouveau n&oelig;ud, ajoutant ainsi effectivement l'&eacute;l&eacute;ment &agrave; la fin de la liste.</p></li><li class="list__item" id="bz5h75_602"><p>Enfin, elle incr&eacute;mente <code class="code" id="bz5h75_603">list.size</code> pour refl&eacute;ter l'ajout du nouveau n&oelig;ud &agrave; la liste.</p></li></ul><p id="bz5h75_604">Voici le segment de code correspondant :</p><div class="code-block" data-lang="go">
func (list *IntList) AddEnd(element int) {
	if list.start == nil {
		list.start = &amp;intNode{value: element}
		list.end = list.start
	} else {
		list.end.next = &amp;intNode{value: element}
		list.end = list.end.next
	}
	list.size++
}
</div><p id="bz5h75_606">Les autres m&eacute;thodes de liste d&eacute;finies dans votre code effectuent diff&eacute;rents op&eacute;rations sur ce type <code class="code" id="bz5h75_607">IntList</code>, telles que ajouter un &eacute;l&eacute;ment au d&eacute;but de la liste (<code class="code" id="bz5h75_608">AddStart</code>), supprimer un &eacute;l&eacute;ment du d&eacute;but de la liste (<code class="code" id="bz5h75_609">RemoveStart</code>), ins&eacute;rer un &eacute;l&eacute;ment &agrave; une position donn&eacute;e (<code class="code" id="bz5h75_610">Insert</code>), et ainsi de suite.</p><p id="bz5h75_611"><code class="code" id="bz5h75_612">intNode</code> est un struct repr&eacute;sentant un n&oelig;ud dans la liste avec une valeur et un pointeur vers le n&oelig;ud suivant.</p></section><section class="chapter"><h3 id="insert" data-toc="insert"><code class="code" id="bz5h75_614">Insert</code></h3><p id="bz5h75_615">Ajouter un &eacute;l&eacute;ment &agrave; une position sp&eacute;cifique dans la liste cha&icirc;n&eacute;e.</p><div class="code-block" data-lang="go">
func (list *IntList) Insert(element int, pos int) error {
</div><p id="bz5h75_617">Cette ligne commence la d&eacute;finition d'une fonction nomm&eacute;e <code class="code" id="bz5h75_618">Insert</code> sur le type de structure <code class="code" id="bz5h75_619">IntList</code>. Elle prend deux param&egrave;tres : un entier <code class="code" id="bz5h75_620">element</code> qui sera ins&eacute;r&eacute;, et un entier <code class="code" id="bz5h75_621">pos</code> qui est la position dans la liste o&ugrave; l'&eacute;l&eacute;ment sera ins&eacute;r&eacute;. La fonction 'Insert' renvoie une erreur si quelque chose se passe mal.</p><p id="bz5h75_622">L'instruction switch suivante couvre diff&eacute;rents sc&eacute;narios de <code class="code" id="bz5h75_623">pos</code>.</p><div class="code-block" data-lang="go">
	switch {
	case pos &lt; 0 || pos &gt; list.size:
		return errors.New(&quot;invalid position&quot;)
	case pos == 0:
		list.AddStart(element)
	case pos == list.size:
		list.AddEnd(element)
	default:
		current := list.start
		for i := 0; i &lt; pos-1; i++ {
			current = current.next
		}
		newNode := &amp;intNode{value: element, next: current.next}
		current.next = newNode
		list.size++
	}
</div><ul class="list _bullet" id="bz5h75_625"><li class="list__item" id="bz5h75_626"><p><code class="code" id="bz5h75_627">case pos &lt; 0 || pos &gt; list.size:</code> v&eacute;rifie si la position sp&eacute;cifi&eacute;e est inf&eacute;rieure &agrave; 0 ou sup&eacute;rieure &agrave; la taille de la liste. Si l'une ou l'autre de ces conditions est satisfaite, alors il n'est pas possible d'ins&eacute;rer le nouvel &eacute;l&eacute;ment &agrave; cette position, et une erreur est renvoy&eacute;e.</p></li><li class="list__item" id="bz5h75_628"><p><code class="code" id="bz5h75_629">case pos == 0:</code> g&egrave;re le sc&eacute;nario o&ugrave; la position pour ins&eacute;rer l'&eacute;l&eacute;ment est 0. Cela signifie que le nouvel &eacute;l&eacute;ment doit &ecirc;tre ajout&eacute; au d&eacute;but de la liste. La fonction <code class="code" id="bz5h75_630">AddStart</code> est appel&eacute;e ici pour ajouter le nouvel &eacute;l&eacute;ment en d&eacute;but de liste.</p></li><li class="list__item" id="bz5h75_631"><p><code class="code" id="bz5h75_632">case pos == list.size:</code> g&egrave;re le sc&eacute;nario o&ugrave; la position pour ins&eacute;rer l'&eacute;l&eacute;ment est &eacute;gale &agrave; la taille de la liste. Cela signifie que le nouvel &eacute;l&eacute;ment doit &ecirc;tre ajout&eacute; &agrave; la fin de la liste. La fonction <code class="code" id="bz5h75_633">AddEnd</code> est appel&eacute;e ici pour ajouter le nouvel &eacute;l&eacute;ment &agrave; la fin de la liste.</p></li><li class="list__item" id="bz5h75_634"><p><code class="code" id="bz5h75_635">default:</code> couvre toutes les autres positions possibles &agrave; l'int&eacute;rieur de la liste. Il parcourt la liste jusqu'&agrave; la position correcte et ins&egrave;re le nouveau n&oelig;ud.</p></li></ul><p id="bz5h75_636">Enfin,</p><div class="code-block" data-lang="go">
	return nil
}
</div><p id="bz5h75_638">Cette ligne indique que la fonction a r&eacute;ussi, car elle s'ex&eacute;cute uniquement si aucune erreur ne s'est produite auparavant.</p></section><section class="chapter"><h3 id="removestart" data-toc="removestart"><code class="code" id="bz5h75_640">RemoveStart</code></h3><p id="bz5h75_641">Supprime le premier &eacute;l&eacute;ment dans la liste li&eacute;e.</p><p id="bz5h75_642">Voici une explication plus d&eacute;taill&eacute;e :</p><div class="code-block" data-lang="go">
func (list *IntList) RemoveStart() (int, error) {
	if list.start == nil {
		return 0, errors.New(&quot;empty list, cannot remove&quot;)
	}
</div><p id="bz5h75_644">D'abord, la m&eacute;thode v&eacute;rifie si la liste est vide en v&eacute;rifiant si <code class="code" id="bz5h75_645">list.start</code> est <code class="code" id="bz5h75_646">nil</code>. Si c'est le cas, une erreur est renvoy&eacute;e indiquant qu'on ne peut pas supprimer un &eacute;l&eacute;ment d'une liste vide.</p><div class="code-block" data-lang="go">
element := list.start.value
	list.start = list.start.next
	list.size--
</div><p id="bz5h75_648">Ensuite, si la liste n'est pas vide, la m&eacute;thode extrait la valeur du premier &eacute;l&eacute;ment pour la retourner plus tard et met &agrave; jour le point de d&eacute;part de la liste pour passer &agrave; l'&eacute;l&eacute;ment suivant dans la liste. La <code class="code" id="bz5h75_649">size</code> de la liste est d&eacute;cr&eacute;ment&eacute;e de 1.</p><div class="code-block" data-lang="go">
if list.size == 0 {
    list.end = nil
}
return element, nil
</div><p id="bz5h75_651">Apr&egrave;s cela, si la taille de la liste devient maintenant 0, la fin de la liste est &eacute;galement mise &agrave; nil. Enfin, la m&eacute;thode retourne la valeur de l'&eacute;l&eacute;ment de d&eacute;part supprim&eacute; et aucune erreur puisque l'op&eacute;ration a r&eacute;ussi. S'il y a un probl&egrave;me avec la liste (comme si elle est vide), l'erreur sera non nulle.</p></section><section class="chapter"><h3 id="removeend" data-toc="removeend"><code class="code" id="bz5h75_653">RemoveEnd()</code></h3><p id="bz5h75_654">Supprime le dernier &eacute;l&eacute;ment dans la liste li&eacute;e.</p><div class="code-block" data-lang="go">
func (list *IntList) RemoveEnd() (int, error) {
	var element int
	// liste vide
	if list.end == nil {
		return element, errors.New(&quot;liste vide, impossible de supprimer&quot;)
	}
	if list.end == list.start {
		// seulement 1 élément dans la liste
		element = list.end.value
		list.start = nil
		list.end = nil
	} else {
		//au moins 2 éléments dans la liste
		newEnd := list.start
		for newEnd.next != list.end {
			newEnd = newEnd.next
		}
		element = list.end.value
		list.end = newEnd
		list.end.next = nil
	}
	list.size--
	return element, nil
}
</div><ul class="list _bullet" id="bz5h75_656"><li class="list__item" id="bz5h75_657"><p>La fonction essaie de supprimer un &eacute;l&eacute;ment de la fin de la liste.</p></li><li class="list__item" id="bz5h75_658"><p>Si la liste est vide (<code class="code" id="bz5h75_659">list.end == nil</code>), elle renvoie une erreur indiquant &quot;liste vide, impossible de supprimer&quot;.</p></li><li class="list__item" id="bz5h75_660"><p>S'il n'y &agrave; qu'un seul &eacute;l&eacute;ment dans la liste (<code class="code" id="bz5h75_661">list.start == list.end</code>), elle supprime l'&eacute;l&eacute;ment, puis d&eacute;finir <code class="code" id="bz5h75_662">list.start</code> &amp; <code class="code" id="bz5h75_663">list.end</code> &agrave; <code class="code" id="bz5h75_664">nil</code>.</p></li><li class="list__item" id="bz5h75_665"><p>S'il y a plus d'un &eacute;l&eacute;ment, elle parcourt la liste jusqu'&agrave; ce qu'elle trouve l'avant-dernier &eacute;l&eacute;ment (<code class="code" id="bz5h75_666">newEnd.next != list.end</code>). Elle supprime alors le dernier &eacute;l&eacute;ment en d&eacute;finissant <code class="code" id="bz5h75_667">list.end</code> au <code class="code" id="bz5h75_668">newEnd</code>, c'est-&agrave;-dire, l'avant-dernier devient le nouvel &eacute;l&eacute;ment de fin. Le suivant de <code class="code" id="bz5h75_669">list.end</code> est d&eacute;fini &agrave; <code class="code" id="bz5h75_670">nil</code>, supprimant toute r&eacute;f&eacute;rence au dernier &eacute;l&eacute;ment.</p></li><li class="list__item" id="bz5h75_671"><p>&Agrave; la fin, la taille de la liste est diminu&eacute;e de 1.</p></li></ul></section><section class="chapter"><h3 id="remove" data-toc="remove"><code class="code" id="bz5h75_673">Remove</code></h3><p id="bz5h75_674">Enlever un &eacute;l&eacute;ment &agrave; une position (un index) sp&eacute;cifi&eacute;.</p><div class="code-block" data-lang="go">
func (list *IntList) Remove(pos int) (int, error) {
	switch {
	case pos &lt; 0 || pos &gt;= list.size:
		return 0, errors.New(&quot;invalid position&quot;)
	case pos == 0:
		return list.RemoveStart()
	case pos == list.size-1:
		return list.RemoveEnd()
	default:
		current := list.start
		for i := 0; i &lt; pos-1; i++ {
			current = current.next
		}
		element := current.next.value
		current.next = current.next.next
		list.size--
		return element, nil
	}
}
</div><p id="bz5h75_676">Cette fonction supprime un &eacute;l&eacute;ment de <code class="code" id="bz5h75_677">IntList</code> &agrave; une position sp&eacute;cifi&eacute;e, <code class="code" id="bz5h75_678">pos</code>, et renvoie cette valeur ainsi que toute erreur qui pourrait survenir.</p><ol class="list _decimal" id="bz5h75_679" type="1"><li class="list__item" id="bz5h75_680"><p>Si <code class="code" id="bz5h75_681">pos</code> est inf&eacute;rieur &agrave; 0 ou sup&eacute;rieur ou &eacute;gal &agrave; la taille de la liste, la fonction renvoie une erreur, car la position est invalide.</p></li><li class="list__item" id="bz5h75_682"><p>Si <code class="code" id="bz5h75_683">pos</code> est 0, la m&eacute;thode <code class="code" id="bz5h75_684">RemoveStart()</code> est appel&eacute;e, qui supprime le premier n&oelig;ud de la liste, et renvoie sa valeur.</p></li><li class="list__item" id="bz5h75_685"><p>Si <code class="code" id="bz5h75_686">pos</code> &eacute;quivaut &agrave; <code class="code" id="bz5h75_687">list.size - 1</code>, la m&eacute;thode <code class="code" id="bz5h75_688">RemoveEnd()</code> est appel&eacute;e qui supprime le dernier &eacute;l&eacute;ment de la liste, et renvoie sa valeur.</p></li><li class="list__item" id="bz5h75_689"><p>Si <code class="code" id="bz5h75_690">pos</code> est une position valide autre que 0 ou la fin de la liste, la fonction parcours la liste jusqu'&agrave; ce qu'elle atteigne <code class="code" id="bz5h75_691">pos - 1</code> (le n&oelig;ud juste avant celui que nous voulons supprimer) puis &eacute;limine le n&oelig;ud <code class="code" id="bz5h75_692">pos</code> en liant le pointeur <code class="code" id="bz5h75_693">next</code> de <code class="code" id="bz5h75_694">pos - 1</code> au n&oelig;ud suivant de <code class="code" id="bz5h75_695">pos</code> (<code class="code" id="bz5h75_696">pos + 1</code>), contournant ainsi le n&oelig;ud <code class="code" id="bz5h75_697">pos</code>.</p></li><li class="list__item" id="bz5h75_698"><p>La taille de la liste est d&eacute;cr&eacute;ment&eacute;e de 1, signifiant qu'un n&oelig;ud a &eacute;t&eacute; supprim&eacute;.</p></li><li class="list__item" id="bz5h75_699"><p>La valeur du n&oelig;ud supprim&eacute; est retourn&eacute;e avec <code class="code" id="bz5h75_700">nil</code> symbolisant qu'il n'y a pas eu d'erreurs.</p></li></ol></section></section><div class="last-modified">Last modified: 29 avril 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ch07s01-section-1-les-dictionnaires.html" class="navigation-links__prev">Section 1 : Les dictionnaires (map)</a><a href="ch08-chapitre-8-fils-d-execution.html" class="navigation-links__next">Chapitre 8 : Fils d&apos;ex&eacute;cution</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>