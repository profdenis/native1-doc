<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-29T10:29:26.543481421"><title>Section 2 : &Eacute;crire dans un fichier | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"exemple-simple-d-criture-dans-un-fichier","level":0,"title":"Exemple simple d\u0027écriture dans un fichier","anchor":"#exemple-simple-d-criture-dans-un-fichier"},{"id":"exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier","level":0,"title":"Exemple : écrire des données entrées par l\u0027utilisateur dans un fichier","anchor":"#exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier"},{"id":"lire-et-crire-des-fichiers-csv","level":0,"title":"Lire et écrire des fichiers CSV","anchor":"#lire-et-crire-des-fichiers-csv"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/ch04s02-section-2-ecrire-dans-un-fichier.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/ch04s02-section-2-ecrire-dans-un-fichier.html#webpage",
    "url": "writerside-documentation/ch04s02-section-2-ecrire-dans-un-fichier.html",
    "name": "Section 2 : &Eacute;crire dans un fichier | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="ch04s02-Section-2-Ecrire-dans-un-fichier" data-main-title="Section 2 : Écrire dans un fichier" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="ch04-Chapitre-4-La-gestion-des-fichiers.md|Chapitre 4 : La gestion des fichiers"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch04s02-Section-2-Ecrire-dans-un-fichier" id="ch04s02-Section-2-Ecrire-dans-un-fichier.md">Section 2 : Écrire dans un fichier</h1><p id="-w42apg_148">La fa&ccedil;on la plus simple de d'ouvrir un fichier pour l'&eacute;criture est avec la fonction <code class="code" id="-w42apg_149">os.Create</code>. Elle s'appelle de cette fa&ccedil;on parce que si le fichier n'existe pas, alors le fichier va &ecirc;tre cr&eacute;&eacute; avant de pouvoir y &eacute;crire. Si le fichier existe d&eacute;j&agrave;, il sera <span class="emphasis" id="-w42apg_150">tronqu&eacute;</span>, c'est-&agrave;-dire que sont contenu sera effac&eacute; et pour ensuite y &eacute;crire &agrave; partir du d&eacute;but. C'est comme ai on &eacute;crivait par-dessus le fichier existant.</p><section class="chapter"><h2 id="exemple-simple-d-criture-dans-un-fichier" data-toc="exemple-simple-d-criture-dans-un-fichier">Exemple simple d'&eacute;criture dans un fichier</h2><div class="code-block" data-lang="go">
func section2a(filename string) {
	// Créer un nouveau fichier, ou le tronquer s'il existe
	file, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Écrire des bytes dans le fichier
	bytesWritten, err := file.WriteString(&quot;Bonjour tout le monde !&quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf(&quot;Écrit %d bytes.\n&quot;, bytesWritten)
}
</div><ol class="list _decimal" id="-w42apg_152" type="1"><li class="list__item" id="-w42apg_153"><p>La fonction a comme param&egrave;tre le nom du fichier <code class="code" id="-w42apg_154">filename</code> dans lequel on doit &eacute;crire.</p></li><li class="list__item" id="-w42apg_155"><p>On commence par cr&eacute;ation du nouveau fichier en utilisant la fonction <code class="code" id="-w42apg_156">os.Create</code> avec le nom de fichier fourni en argument. Cette fonction cr&eacute;e un nouveau fichier et si le fichier existe d&eacute;j&agrave;, elle tronque le contenu du fichier. Le r&eacute;sultat de la fonction <code class="code" id="-w42apg_157">os.Create</code> comprend deux variables. La premi&egrave;re est un pointeur de de fichier <code class="code" id="-w42apg_158">file</code> qui est utilis&eacute;e pour les op&eacute;rations de fichier ult&eacute;rieures et la seconde est une erreur <code class="code" id="-w42apg_159">err</code> qui aurait pu se produire.</p></li><li class="list__item" id="-w42apg_160"><p>On v&eacute;rifie ensuite s'il y a eu une erreur lors de la cr&eacute;ation du fichier. S'il y a eu une erreur (<code class="code" id="-w42apg_161">err</code> n'est pas <code class="code" id="-w42apg_162">nil</code>), on logue l'erreur et termine imm&eacute;diatement le programme en utilisant <code class="code" id="-w42apg_163">log.Fatal(err)</code>.</p></li><li class="list__item" id="-w42apg_164"><p>L'instruction <code class="code" id="-w42apg_165">defer file.Close()</code> fait en sorte que <code class="code" id="-w42apg_166">file.Close()</code> soit appel&eacute;e juste avant que la fonction <code class="code" id="-w42apg_167">section2a</code> ne se termine, soit normalement ou via une erreur non trait&eacute;e, afin de lib&eacute;rer les ressources du syst&egrave;me (voir les d&eacute;tails plus bas).</p></li><li class="list__item" id="-w42apg_168"><p>Ensuite, on utilise la fonction <code class="code" id="-w42apg_169">file.WriteString</code> pour &eacute;crire une cha&icirc;ne de caract&egrave;res dans le fichier. Le comptage en octets du contenu &eacute;crit est stock&eacute; dans <code class="code" id="-w42apg_170">bytesWritten</code>, et toute erreur pendant le processus est stock&eacute;e dans <code class="code" id="-w42apg_171">err</code>.</p></li><li class="list__item" id="-w42apg_172"><p>Encore une fois, toute erreur lors de l'&eacute;criture dans le fichier est v&eacute;rifi&eacute;e et s'il y a eu une erreur, le programme enregistre l'erreur et se termine imm&eacute;diatement.</p></li><li class="list__item" id="-w42apg_173"><p>Si l'&eacute;criture des bytes est r&eacute;ussie, le nombre de bytes &eacute;crits est enregistr&eacute; dans le journal (<code class="code" id="-w42apg_174">log</code>).</p></li></ol><p id="-w42apg_175">Si on n'utilisait pas <code class="code" id="-w42apg_176">defer</code> ici, et qu'on appelait <code class="code" id="-w42apg_177">Close</code> &agrave; la fin de la fonction comme dans les exemples pr&eacute;c&eacute;dents, alors &ccedil;a pourrait cr&eacute;er des probl&egrave;mes. Quand on ouvre un fichier (ou toute autre resource), il faut s'assurer de la fermer, ou lib&eacute;rer, avant de quitter la fonction. Si on a un <code class="code" id="-w42apg_178">return</code> avant de se rendre &agrave; la fin de la fonction, ou si on quitte &agrave; cause d'une erreur, comme avec <code class="code" id="-w42apg_179">log.Fatal</code> ou avec une panique (une erreur grave au moment de l'ex&eacute;cution), alors le fichier, ou en g&eacute;n&eacute;ral la resource, ne sera pas ferm&eacute;e, et &ccedil;a pourrait causer des probl&egrave;mes, comme des fuites de m&eacute;moires ou, dans notre cas, des donn&eacute;es qui ne seraient pas enregistr&eacute;es correctement dans le fichier ouvert. Si on n'utilise pas <code class="code" id="-w42apg_180">defer</code>, il faudrait appeler <code class="code" id="-w42apg_181">file.Close()</code> possiblement &agrave; plusieurs endroits, &agrave; chaque endroit o&ugrave; on pourrait potentiellement quitter la fonction. Dans certains cas, comme pour les paniques, elles pourraient arriver &agrave; des endroits impr&eacute;vus, donc la resource pourrait ne jamais &ecirc;tre correctement ferm&eacute;e ou lib&eacute;r&eacute;e.</p><p id="-w42apg_182">L'utilisation de <code class="code" id="-w42apg_183">defer file.Close()</code> nous assure que le fichier sera ferm&eacute;, peu importe la fa&ccedil;on dont nous quittons la fonction. Dans les exemples pr&eacute;c&eacute;dents, puisque les fichiers &eacute;taient ouverts en lecture seule, le fichier n'&eacute;tait pas modifi&eacute;, donc on ne pouvait pas perdre de donn&eacute;es si le fichier n'&eacute;tait pas ferm&eacute; correctement. Mais il est tout de m&ecirc;me pr&eacute;f&eacute;rable d'utiliser <code class="code" id="-w42apg_184">defer</code> dans tous les cas pour s'assurer d'une bonne gestion de la m&eacute;moire, pour ne pas conserver les contenu des fichiers en m&eacute;moire pour rien.</p></section><section class="chapter"><h2 id="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier" data-toc="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier">Exemple : &eacute;crire des donn&eacute;es entr&eacute;es par l'utilisateur dans un fichier</h2><p id="-w42apg_185">La fonction suivante demande des entr&eacute;es &agrave; l'utilisateur et &eacute;crit ces entr&eacute;es dans un fichier <span class="emphasis" id="-w42apg_186">CSV</span> en utilisant les op&eacute;rations d'E/S de fichiers de la biblioth&egrave;que standard.</p><div class="code-block" data-lang="go">
func section2b() {
	nAttempts := 3
	// demander le nom du fichier
	fmt.Print(&quot;Nom du fichier dans lequel enregistrer les données : &quot;)
	filename, err := ReadNonEmptyLine(nAttempts)
	if err != nil {
		log.Fatalf(&quot;Impossible de lire le nom du fichier : %s&quot;, err)
	}

	// ouvrir le fichier
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf(&quot;Impossible d'ouvrir le fichier : %s&quot;, err)
	}
	defer file.Close()

	done := false
	for !done {
		// lire le nom
		fmt.Print(&quot;Veuillez entrer votre nom : &quot;)
		name, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire le nom : %s&quot;, err)
		} else {
			// s'il n'y a pas d'erreur, lire l'âge
			fmt.Print(&quot;Veuillez entrer votre âge : &quot;)
			age, err := ReadInt(nAttempts)
			if err != nil {
				log.Printf(&quot;Impossible de lire l'âge : %s&quot;, err)
			} else {
				// s'il n'y a pas d'erreur
				line := fmt.Sprintf(&quot;%s,%d\n&quot;, name, age)
				_, err = file.WriteString(line)
				if err != nil {
					log.Fatalf(&quot;Impossible d'écrire dans le fichier : %s&quot;, err)
				}
			}
		}

		// continuer ou non ?
		fmt.Println(&quot;Voulez-vous entrer continuer (O/N) ?&quot;)
		continueInput, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire la réponse : %s&quot;, err)
		} else {
			if strings.ToUpper(continueInput) == &quot;N&quot; {
				done = true
			}
		}
	}
}
</div><p id="-w42apg_188">Voici un pas &agrave; pas de la fonction <code class="code" id="-w42apg_189">section2b</code>:</p><ol class="list _decimal" id="-w42apg_190" type="1"><li class="list__item" id="-w42apg_191"><p>La fonction <code class="code" id="-w42apg_192">section2b</code> commence par d&eacute;clarer une variable <code class="code" id="-w42apg_193">nAttempts</code> qui d&eacute;finit une limite au nombre de tentatives de lecture des entr&eacute;es.</p></li><li class="list__item" id="-w42apg_194"><p>Elle demande &agrave; l'utilisateur de saisir le nom du fichier dans lequel les donn&eacute;es doivent &ecirc;tre enregistr&eacute;es. Ceci est fait via l'appel &agrave; <code class="code" id="-w42apg_195">ReadNonEmptyLine(nAttempts)</code>. Si le nom du fichier est lu avec succ&egrave;s (non vide et pas d'erreur de lecture), il continue, sinon il quitte le programme en enregistrant l'erreur fatale.</p></li><li class="list__item" id="-w42apg_196"><p>Ensuite, elle tente de cr&eacute;er le fichier sp&eacute;cifi&eacute; &agrave; l'aide de <code class="code" id="-w42apg_197">os.Create(filename)</code>. Si une erreur se produit pendant la cr&eacute;ation du fichier, une erreur fatale est enregistr&eacute;e et le programme quitte. La fermeture du fichier est report&eacute; apr&egrave;s que toutes les op&eacute;rations suivantes ont &eacute;t&eacute; termin&eacute;es.</p></li><li class="list__item" id="-w42apg_198"><p>Elle entre ensuite dans une boucle qui continue jusqu'&agrave; ce que <code class="code" id="-w42apg_199">done</code> devienne vraie.</p></li><li class="list__item" id="-w42apg_200"><p>Dans la boucle, elle demande d'abord &agrave; l'utilisateur d'entrer son nom, en utilisant une v&eacute;rification des erreurs similaire &agrave; l'entr&eacute;e pr&eacute;c&eacute;dente. Si le nom est lu avec succ&egrave;s, elle demande ensuite l'&acirc;ge &agrave; l'aide de la fonction <code class="code" id="-w42apg_201">ReadInt(nAttempts)</code>. Sinon, elle enregistre l'erreur et r&eacute;p&egrave;te la boucle.</p></li><li class="list__item" id="-w42apg_202"><p>S'il n'y a pas d'erreur lors de la lecture de l'&acirc;ge, elle formate le nom et l'&acirc;ge en une cha&icirc;ne avec <code class="code" id="-w42apg_203">fmt.Sprintf</code>, puis tente d'&eacute;crire cette cha&icirc;ne dans le fichier ouvert &agrave; l'aide de <code class="code" id="-w42apg_204">file.WriteString(line)</code>. Elle v&eacute;rifie les erreurs lors de l'op&eacute;ration d'&eacute;criture, enregistre l'erreur fatale et quitte si n&eacute;cessaire.</p></li><li class="list__item" id="-w42apg_205"><p>Ensuite, elle demande &agrave; l'utilisateur s'il souhaite continuer &agrave; entrer plus de donn&eacute;es. Si l'utilisateur saisit <code class="code" id="-w42apg_206">'N'</code> ou <code class="code" id="-w42apg_207">'n'</code>, elle change <code class="code" id="-w42apg_208">done</code> &agrave; <code class="code" id="-w42apg_209">true</code> ce qui brisera la boucle, sinon elle retourne &agrave; la demande du nom et de l'&acirc;ge.</p></li></ol><p id="-w42apg_210"><span class="control" id="-w42apg_211">Note</span>: le paquet <code class="code" id="-w42apg_212">encoding/csv</code> offre une meilleure interface pour lire et &eacute;crire des fichiers <span class="emphasis" id="-w42apg_213">CSV</span>. L'exemple pr&eacute;c&eacute;dent &eacute;crit du texte directement dans le fichier. <code class="code" id="-w42apg_214">encoding/csv</code> permet de lire et d'&eacute;crire plus efficacement. Deux fonctions qui utilisent <code class="code" id="-w42apg_215">encoding/csv</code> suivent. La premi&egrave;re lit un fichier <span class="emphasis" id="-w42apg_216">CSV</span>, et l'autre &eacute;crit dans un fichier <span class="emphasis" id="-w42apg_217">CSV</span>.</p></section><section class="chapter"><h2 id="lire-et-crire-des-fichiers-csv" data-toc="lire-et-crire-des-fichiers-csv">Lire et &eacute;crire des fichiers <span class="emphasis" id="-w42apg_219">CSV</span></h2><div class="code-block" data-lang="go">
func readCSVFile() {
	f, err := os.Open(&quot;abc.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	reader := csv.NewReader(f)
	records, err := reader.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	for _, record := range records {
		fmt.Println(record) // record est une tranche de chaînes de 
		                    // caractères représentant les lignes du fichier
	}
}

func writeCSVFile() {
	f, err := os.Create(&quot;def.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	writer := csv.NewWriter(f)
	data := []string{&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;}

	if err := writer.Write(data); err != nil {
		log.Fatal(err)
	}
	writer.Flush()

	if err := writer.Error(); err != nil {
		log.Fatal(err)
	}
}
</div></section><div class="last-modified">Last modified: 29 avril 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ch04s01-section-1-lire-le-contenu-d-un-fichier.html" class="navigation-links__prev">Section 1 : Lire le contenu d&apos;un fichier</a><a href="ch04s03-section-3-copier-un-fichier.html" class="navigation-links__next">Section 3 : Copier un fichier en ajoutant des num&eacute;ros de ligne</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>