<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-02-26T08:37:32.962449433"><title>Section 2 : &Eacute;crire dans un fichier | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"exemple-simple-d-criture-dans-un-fichier","level":0,"title":"Exemple simple d\u0027écriture dans un fichier","anchor":"#exemple-simple-d-criture-dans-un-fichier"},{"id":"exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier","level":0,"title":"Exemple : écrire des données entrées par l\u0027utilisateur dans un fichier","anchor":"#exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier"},{"id":"lire-et-crire-des-fichiers-csv","level":0,"title":"Lire et écrire des fichiers CSV","anchor":"#lire-et-crire-des-fichiers-csv"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="ch04s02-section-2-ecrire-dans-un-fichier.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "ch04s02-section-2-ecrire-dans-un-fichier.html#webpage",
    "url": "ch04s02-section-2-ecrire-dans-un-fichier.html",
    "name": "Section 2 : &Eacute;crire dans un fichier | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "/#website",
    "url": "/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="ch04s02-Section-2-Ecrire-dans-un-fichier" data-main-title="Section 2 : &Eacute;crire dans un fichier" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="ch04-Chapitre-4-La-gestion-des-fichiers.md|Chapitre 4 : La gestion des fichiers"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch04s02-Section-2-Ecrire-dans-un-fichier" id="ch04s02-Section-2-Ecrire-dans-un-fichier.md">Section 2 : &Eacute;crire dans un fichier</h1><p id="1aec3b42_2">La fa&ccedil;on la plus simple de d'ouvrir un fichier pour l'&eacute;criture est avec la fonction <code class="code" id="1aec3b42_3">os.Create</code>. Elle s'appelle de cette fa&ccedil;on parce que si le fichier n'existe pas, alors le fichier va &ecirc;tre cr&eacute;&eacute; avant de pouvoir y &eacute;crire. Si le fichier existe d&eacute;j&agrave;, il sera <span class="emphasis" id="1aec3b42_4">tronqu&eacute;</span>, c'est-&agrave;-dire que sont contenu sera effac&eacute; et pour ensuite y &eacute;crire &agrave; partir du d&eacute;but. C'est comme ai on &eacute;crivait par-dessus le fichier existant.</p><section class="chapter"><h2 id="exemple-simple-d-criture-dans-un-fichier" data-toc="exemple-simple-d-criture-dans-un-fichier">Exemple simple d'&eacute;criture dans un fichier</h2><div class="code-block" data-lang="go">
func section2a(filename string) {
	// Créer un nouveau fichier, ou le tronquer s'il existe
	file, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Écrire des bytes dans le fichier
	bytesWritten, err := file.WriteString(&quot;Bonjour tout le monde !&quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf(&quot;Écrit %d bytes.\n&quot;, bytesWritten)
}
</div><ol class="list _decimal" id="1aec3b42_6" type="1"><li class="list__item" id="1aec3b42_7"><p>La fonction a comme param&egrave;tre le nom du fichier <code class="code" id="1aec3b42_8">filename</code> dans lequel on doit &eacute;crire.</p></li><li class="list__item" id="1aec3b42_9"><p>On commence par cr&eacute;ation du nouveau fichier en utilisant la fonction <code class="code" id="1aec3b42_10">os.Create</code> avec le nom de fichier fourni en argument. Cette fonction cr&eacute;e un nouveau fichier et si le fichier existe d&eacute;j&agrave;, elle tronque le contenu du fichier. Le r&eacute;sultat de la fonction <code class="code" id="1aec3b42_11">os.Create</code> comprend deux variables. La premi&egrave;re est un pointeur de de fichier <code class="code" id="1aec3b42_12">file</code> qui est utilis&eacute;e pour les op&eacute;rations de fichier ult&eacute;rieures et la seconde est une erreur <code class="code" id="1aec3b42_13">err</code> qui aurait pu se produire.</p></li><li class="list__item" id="1aec3b42_14"><p>On v&eacute;rifie ensuite s'il y a eu une erreur lors de la cr&eacute;ation du fichier. S'il y a eu une erreur (<code class="code" id="1aec3b42_15">err</code> n'est pas <code class="code" id="1aec3b42_16">nil</code>), on logue l'erreur et termine imm&eacute;diatement le programme en utilisant <code class="code" id="1aec3b42_17">log.Fatal(err)</code>.</p></li><li class="list__item" id="1aec3b42_18"><p>L'instruction <code class="code" id="1aec3b42_19">defer file.Close()</code> fait en sorte que <code class="code" id="1aec3b42_20">file.Close()</code> soit appel&eacute;e juste avant que la fonction <code class="code" id="1aec3b42_21">section2a</code> ne se termine, soit normalement ou via une erreur non trait&eacute;e, afin de lib&eacute;rer les ressources du syst&egrave;me (voir les d&eacute;tails plus bas).</p></li><li class="list__item" id="1aec3b42_22"><p>Ensuite, on utilise la fonction <code class="code" id="1aec3b42_23">file.WriteString</code> pour &eacute;crire une cha&icirc;ne de caract&egrave;res dans le fichier. Le comptage en octets du contenu &eacute;crit est stock&eacute; dans <code class="code" id="1aec3b42_24">bytesWritten</code>, et toute erreur pendant le processus est stock&eacute;e dans <code class="code" id="1aec3b42_25">err</code>.</p></li><li class="list__item" id="1aec3b42_26"><p>Encore une fois, toute erreur lors de l'&eacute;criture dans le fichier est v&eacute;rifi&eacute;e et s'il y a eu une erreur, le programme enregistre l'erreur et se termine imm&eacute;diatement.</p></li><li class="list__item" id="1aec3b42_27"><p>Si l'&eacute;criture des bytes est r&eacute;ussie, le nombre de bytes &eacute;crits est enregistr&eacute; dans le journal (<code class="code" id="1aec3b42_28">log</code>).</p></li></ol><p id="1aec3b42_29">Si on n'utilisait pas <code class="code" id="1aec3b42_30">defer</code> ici, et qu'on appelait <code class="code" id="1aec3b42_31">Close</code> &agrave; la fin de la fonction comme dans les exemples pr&eacute;c&eacute;dents, alors &ccedil;a pourrait cr&eacute;er des probl&egrave;mes. Quand on ouvre un fichier (ou toute autre resource), il faut s'assurer de la fermer, ou lib&eacute;rer, avant de quitter la fonction. Si on a un <code class="code" id="1aec3b42_32">return</code> avant de se rendre &agrave; la fin de la fonction, ou si on quitte &agrave; cause d'une erreur, comme avec <code class="code" id="1aec3b42_33">log.Fatal</code> ou avec une panique (une erreur grave au moment de l'ex&eacute;cution), alors le fichier, ou en g&eacute;n&eacute;ral la resource, ne sera pas ferm&eacute;e, et &ccedil;a pourrait causer des probl&egrave;mes, comme des fuites de m&eacute;moires ou, dans notre cas, des donn&eacute;es qui ne seraient pas enregistr&eacute;es correctement dans le fichier ouvert. Si on n'utilise pas <code class="code" id="1aec3b42_34">defer</code>, il faudrait appeler <code class="code" id="1aec3b42_35">file.Close()</code> possiblement &agrave; plusieurs endroits, &agrave; chaque endroit o&ugrave; on pourrait potentiellement quitter la fonction. Dans certains cas, comme pour les paniques, elles pourraient arriver &agrave; des endroits impr&eacute;vus, donc la resource pourrait ne jamais &ecirc;tre correctement ferm&eacute;e ou lib&eacute;r&eacute;e.</p><p id="1aec3b42_36">L'utilisation de <code class="code" id="1aec3b42_37">defer file.Close()</code> nous assure que le fichier sera ferm&eacute;, peu importe la fa&ccedil;on dont nous quittons la fonction. Dans les exemples pr&eacute;c&eacute;dents, puisque les fichiers &eacute;taient ouverts en lecture seule, le fichier n'&eacute;tait pas modifi&eacute;, donc on ne pouvait pas perdre de donn&eacute;es si le fichier n'&eacute;tait pas ferm&eacute; correctement. Mais il est tout de m&ecirc;me pr&eacute;f&eacute;rable d'utiliser <code class="code" id="1aec3b42_38">defer</code> dans tous les cas pour s'assurer d'une bonne gestion de la m&eacute;moire, pour ne pas conserver les contenu des fichiers en m&eacute;moire pour rien.</p></section><section class="chapter"><h2 id="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier" data-toc="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier">Exemple : &eacute;crire des donn&eacute;es entr&eacute;es par l'utilisateur dans un fichier</h2><p id="1aec3b42_39">La fonction suivante demande des entr&eacute;es &agrave; l'utilisateur et &eacute;crit ces entr&eacute;es dans un fichier <span class="emphasis" id="1aec3b42_40">CSV</span> en utilisant les op&eacute;rations d'E/S de fichiers de la biblioth&egrave;que standard.</p><div class="code-block" data-lang="go">
func section2b() {
	nAttempts := 3
	// demander le nom du fichier
	fmt.Print(&quot;Nom du fichier dans lequel enregistrer les données : &quot;)
	filename, err := ReadNonEmptyLine(nAttempts)
	if err != nil {
		log.Fatalf(&quot;Impossible de lire le nom du fichier : %s&quot;, err)
	}

	// ouvrir le fichier
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf(&quot;Impossible d'ouvrir le fichier : %s&quot;, err)
	}
	defer file.Close()

	done := false
	for !done {
		// lire le nom
		fmt.Print(&quot;Veuillez entrer votre nom : &quot;)
		name, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire le nom : %s&quot;, err)
		} else {
			// s'il n'y a pas d'erreur, lire l'âge
			fmt.Print(&quot;Veuillez entrer votre âge : &quot;)
			age, err := ReadInt(nAttempts)
			if err != nil {
				log.Printf(&quot;Impossible de lire l'âge : %s&quot;, err)
			} else {
				// s'il n'y a pas d'erreur
				line := fmt.Sprintf(&quot;%s,%d\n&quot;, name, age)
				_, err = file.WriteString(line)
				if err != nil {
					log.Fatalf(&quot;Impossible d'écrire dans le fichier : %s&quot;, err)
				}
			}
		}

		// continuer ou non ?
		fmt.Println(&quot;Voulez-vous entrer continuer (O/N) ?&quot;)
		continueInput, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire la réponse : %s&quot;, err)
		} else {
			if strings.ToUpper(continueInput) == &quot;N&quot; {
				done = true
			}
		}
	}
}
</div><p id="1aec3b42_42">Voici un pas &agrave; pas de la fonction <code class="code" id="1aec3b42_43">section2b</code>:</p><ol class="list _decimal" id="1aec3b42_44" type="1"><li class="list__item" id="1aec3b42_45"><p>La fonction <code class="code" id="1aec3b42_46">section2b</code> commence par d&eacute;clarer une variable <code class="code" id="1aec3b42_47">nAttempts</code> qui d&eacute;finit une limite au nombre de tentatives de lecture des entr&eacute;es.</p></li><li class="list__item" id="1aec3b42_48"><p>Elle demande &agrave; l'utilisateur de saisir le nom du fichier dans lequel les donn&eacute;es doivent &ecirc;tre enregistr&eacute;es. Ceci est fait via l'appel &agrave; <code class="code" id="1aec3b42_49">ReadNonEmptyLine(nAttempts)</code>. Si le nom du fichier est lu avec succ&egrave;s (non vide et pas d'erreur de lecture), il continue, sinon il quitte le programme en enregistrant l'erreur fatale.</p></li><li class="list__item" id="1aec3b42_50"><p>Ensuite, elle tente de cr&eacute;er le fichier sp&eacute;cifi&eacute; &agrave; l'aide de <code class="code" id="1aec3b42_51">os.Create(filename)</code>. Si une erreur se produit pendant la cr&eacute;ation du fichier, une erreur fatale est enregistr&eacute;e et le programme quitte. La fermeture du fichier est report&eacute; apr&egrave;s que toutes les op&eacute;rations suivantes ont &eacute;t&eacute; termin&eacute;es.</p></li><li class="list__item" id="1aec3b42_52"><p>Elle entre ensuite dans une boucle qui continue jusqu'&agrave; ce que <code class="code" id="1aec3b42_53">done</code> devienne vraie.</p></li><li class="list__item" id="1aec3b42_54"><p>Dans la boucle, elle demande d'abord &agrave; l'utilisateur d'entrer son nom, en utilisant une v&eacute;rification des erreurs similaire &agrave; l'entr&eacute;e pr&eacute;c&eacute;dente. Si le nom est lu avec succ&egrave;s, elle demande ensuite l'&acirc;ge &agrave; l'aide de la fonction <code class="code" id="1aec3b42_55">ReadInt(nAttempts)</code>. Sinon, elle enregistre l'erreur et r&eacute;p&egrave;te la boucle.</p></li><li class="list__item" id="1aec3b42_56"><p>S'il n'y a pas d'erreur lors de la lecture de l'&acirc;ge, elle formate le nom et l'&acirc;ge en une cha&icirc;ne avec <code class="code" id="1aec3b42_57">fmt.Sprintf</code>, puis tente d'&eacute;crire cette cha&icirc;ne dans le fichier ouvert &agrave; l'aide de <code class="code" id="1aec3b42_58">file.WriteString(line)</code>. Elle v&eacute;rifie les erreurs lors de l'op&eacute;ration d'&eacute;criture, enregistre l'erreur fatale et quitte si n&eacute;cessaire.</p></li><li class="list__item" id="1aec3b42_59"><p>Ensuite, elle demande &agrave; l'utilisateur s'il souhaite continuer &agrave; entrer plus de donn&eacute;es. Si l'utilisateur saisit <code class="code" id="1aec3b42_60">'N'</code> ou <code class="code" id="1aec3b42_61">'n'</code>, elle change <code class="code" id="1aec3b42_62">done</code> &agrave; <code class="code" id="1aec3b42_63">true</code> ce qui brisera la boucle, sinon elle retourne &agrave; la demande du nom et de l'&acirc;ge.</p></li></ol><p id="1aec3b42_64"><span class="control" id="1aec3b42_65">Note</span>: le paquet <code class="code" id="1aec3b42_66">encoding/csv</code> offre une meilleure interface pour lire et &eacute;crire des fichiers <span class="emphasis" id="1aec3b42_67">CSV</span>. L'exemple pr&eacute;c&eacute;dent &eacute;crit du texte directement dans le fichier. <code class="code" id="1aec3b42_68">encoding/csv</code> permet de lire et d'&eacute;crire plus efficacement. Deux fonctions qui utilisent <code class="code" id="1aec3b42_69">encoding/csv</code> suivent. La premi&egrave;re lit un fichier <span class="emphasis" id="1aec3b42_70">CSV</span>, et l'autre &eacute;crit dans un fichier <span class="emphasis" id="1aec3b42_71">CSV</span>.</p></section><section class="chapter"><h2 id="lire-et-crire-des-fichiers-csv" data-toc="lire-et-crire-des-fichiers-csv">Lire et &eacute;crire des fichiers CSV</h2><div class="code-block" data-lang="go">
func readCSVFile() {
	f, err := os.Open(&quot;abc.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	reader := csv.NewReader(f)
	records, err := reader.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	for _, record := range records {
		fmt.Println(record) // record est une tranche de chaînes de 
		                    // caractères représentant les lignes du fichier
	}
}

func writeCSVFile() {
	f, err := os.Create(&quot;def.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	writer := csv.NewWriter(f)
	data := []string{&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;}

	if err := writer.Write(data); err != nil {
		log.Fatal(err)
	}
	writer.Flush()

	if err := writer.Error(); err != nil {
		log.Fatal(err)
	}
}
</div></section><div class="last-modified">Last modified: 26 février 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ch04s01-section-1-lire-le-contenu-d-un-fichier.html" class="navigation-links__prev">Section 1 : Lire le contenu d&apos;un fichier</a><a href="ch04s03-section-3-copier-un-fichier.html" class="navigation-links__next">Section 3 : Copier un fichier en ajoutant des num&eacute;ros de ligne</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>