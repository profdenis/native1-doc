<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-11T19:40:51.920144392"><meta name="build-number" content="${buildNumber}">       <title>Section 2 : &Eacute;crire dans un fichier | Help Instance</title><script id="virtual-toc-data" type="application/json">[{"id":"exemple-simple-d-criture-dans-un-fichier","level":0,"title":"Exemple simple d\u0027écriture dans un fichier","anchor":"#exemple-simple-d-criture-dans-un-fichier"},{"id":"exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier","level":0,"title":"Exemple : écrire des données entrées par l\u0027utilisateur dans un fichier","anchor":"#exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Help Instance Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="ch04s02-section-2-ecrire-dans-un-fichier.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Section 2 : &Eacute;crire dans un fichier | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "ch04s02-section-2-ecrire-dans-un-fichier.html#webpage", "url": "ch04s02-section-2-ecrire-dans-un-fichier.html", "name": "Section 2 : &Eacute;crire dans un fichier | Help Instance", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Help Instance Help" }</script><!-- End Schema.org --></head>      <body data-id="ch04s02-Section-2-Ecrire-dans-un-fichier" data-main-title="Section 2 : &Eacute;crire dans un fichier" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="ch04-Chapitre-4-La-gestion-des-fichiers.md|Chapitre 4 : La gestion des fichiers"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ch04s02-Section-2-Ecrire-dans-un-fichier"   id="ch04s02-Section-2-Ecrire-dans-un-fichier.md">Section 2 : &Eacute;crire dans un fichier</h1>  <p id="67b42d21_3784">La fa&ccedil;on la plus simple de d'ouvrir un fichier pour l'&eacute;criture est avec la fonction <code class="code" id="67b42d21_3785">os.Create</code>. Elle s'appelle de cette fa&ccedil;on parce que si le fichier n'existe pas, alors le fichier va &ecirc;tre cr&eacute;&eacute; avant de pouvoir y &eacute;crire. Si le fichier existe d&eacute;j&agrave;, il sera <span class="emphasis" id="67b42d21_3786">tronqu&eacute;</span>, c'est-&agrave;-dire que sont contenu sera effac&eacute; et pour ensuite y &eacute;crire &agrave; partir du d&eacute;but. C'est comme ai on &eacute;crivait par-dessus le fichier existant.</p><section class="chapter"><h2 id="exemple-simple-d-criture-dans-un-fichier" data-toc="exemple-simple-d-criture-dans-un-fichier"   >Exemple simple d'&eacute;criture dans un fichier</h2><div class="code-block" data-lang="go"         >
func section2a(filename string) {
	// Cr&eacute;er un nouveau fichier, ou le tronquer s'il existe
	file, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// &Eacute;crire des bytes dans le fichier
	bytesWritten, err := file.WriteString(&quot;Bonjour tout le monde !&quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf(&quot;&Eacute;crit %d bytes.\n&quot;, bytesWritten)
}
</div><ol class="list _decimal" id="67b42d21_3788" type="1"><li class="list__item" id="67b42d21_3789"><p>La fonction a comme param&egrave;tre le nom du fichier <code class="code" id="67b42d21_3790">filename</code> dans lequel on doit &eacute;crire.</p></li><li class="list__item" id="67b42d21_3791"><p>On commence par cr&eacute;ation du nouveau fichier en utilisant la fonction <code class="code" id="67b42d21_3792">os.Create</code> avec le nom de fichier fourni en argument. Cette fonction cr&eacute;e un nouveau fichier et si le fichier existe d&eacute;j&agrave;, elle tronque le contenu du fichier. Le r&eacute;sultat de la fonction <code class="code" id="67b42d21_3793">os.Create</code> comprend deux variables. La premi&egrave;re est un pointeur de de fichier <code class="code" id="67b42d21_3794">file</code> qui est utilis&eacute;e pour les op&eacute;rations de fichier ult&eacute;rieures et la seconde est une erreur <code class="code" id="67b42d21_3795">err</code> qui aurait pu se produire.</p></li><li class="list__item" id="67b42d21_3796"><p>On v&eacute;rifie ensuite s'il y a eu une erreur lors de la cr&eacute;ation du fichier. S'il y a eu une erreur (<code class="code" id="67b42d21_3797">err</code> n'est pas <code class="code" id="67b42d21_3798">nil</code>), on logue l'erreur et termine imm&eacute;diatement le programme en utilisant <code class="code" id="67b42d21_3799">log.Fatal(err)</code>.</p></li><li class="list__item" id="67b42d21_3800"><p>L'instruction <code class="code" id="67b42d21_3801">defer file.Close()</code> fait en sorte que <code class="code" id="67b42d21_3802">file.Close()</code> soit appel&eacute;e juste avant que la fonction <code class="code" id="67b42d21_3803">section2a</code> ne se termine, soit normalement ou via une erreur non trait&eacute;e, afin de lib&eacute;rer les ressources du syst&egrave;me (voir les d&eacute;tails plus bas).</p></li><li class="list__item" id="67b42d21_3804"><p>Ensuite, on utilise la fonction <code class="code" id="67b42d21_3805">file.WriteString</code> pour &eacute;crire une cha&icirc;ne de caract&egrave;res dans le fichier. Le comptage en octets du contenu &eacute;crit est stock&eacute; dans <code class="code" id="67b42d21_3806">bytesWritten</code>, et toute erreur pendant le processus est stock&eacute;e dans <code class="code" id="67b42d21_3807">err</code>.</p></li><li class="list__item" id="67b42d21_3808"><p>Encore une fois, toute erreur lors de l'&eacute;criture dans le fichier est v&eacute;rifi&eacute;e et s'il y a eu une erreur, le programme enregistre l'erreur et se termine imm&eacute;diatement.</p></li><li class="list__item" id="67b42d21_3809"><p>Si l'&eacute;criture des bytes est r&eacute;ussie, le nombre de bytes &eacute;crits est enregistr&eacute; dans le journal (<code class="code" id="67b42d21_3810">log</code>).</p></li></ol><p id="67b42d21_3811">Si on n'utilisait pas <code class="code" id="67b42d21_3812">defer</code> ici, et qu'on appelait <code class="code" id="67b42d21_3813">Close</code> &agrave; la fin de la fonction comme dans les exemples pr&eacute;c&eacute;dents, alors &ccedil;a pourrait cr&eacute;er des probl&egrave;mes. Quand on ouvre un fichier (ou toute autre resource), il faut s'assurer de la fermer, ou lib&eacute;rer, avant de quitter la fonction. Si on a un <code class="code" id="67b42d21_3814">return</code> avant de se rendre &agrave; la fin de la fonction, ou si on quitte &agrave; cause d'une erreur, comme avec <code class="code" id="67b42d21_3815">log.Fatal</code> ou avec une panique (une erreur grave au moment de l'ex&eacute;cution), alors le fichier, ou en g&eacute;n&eacute;ral la resource, ne sera pas ferm&eacute;e, et &ccedil;a pourrait causer des probl&egrave;mes, comme des fuites de m&eacute;moires ou, dans notre cas, des donn&eacute;es qui ne seraient pas enregistr&eacute;es correctement dans le fichier ouvert. Si on n'utilise pas <code class="code" id="67b42d21_3816">defer</code>, il faudrait appeler <code class="code" id="67b42d21_3817">file.Close()</code> possiblement &agrave; plusieurs endroits, &agrave; chaque endroit o&ugrave; on pourrait potentiellement quitter la fonction. Dans certains cas, comme pour les paniques, elles pourraient arriver &agrave; des endroits impr&eacute;vus, donc la resource pourrait ne jamais &ecirc;tre correctement ferm&eacute;e ou lib&eacute;r&eacute;e.</p><p id="67b42d21_3818">L'utilisation de <code class="code" id="67b42d21_3819">defer file.Close()</code> nous assure que le fichier sera ferm&eacute;, peu importe la fa&ccedil;on dont nous quittons la fonction. Dans les exemples pr&eacute;c&eacute;dents, puisque les fichiers &eacute;taient ouverts en lecture seule, le fichier n'&eacute;tait pas modifi&eacute;, donc on ne pouvait pas perdre de donn&eacute;es si le fichier n'&eacute;tait pas ferm&eacute; correctement. Mais il est tout de m&ecirc;me pr&eacute;f&eacute;rable d'utiliser <code class="code" id="67b42d21_3820">defer</code> dans tous les cas pour s'assurer d'une bonne gestion de la m&eacute;moire, pour ne pas conserver les contenu des fichiers en m&eacute;moire pour rien.</p></section><section class="chapter"><h2 id="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier" data-toc="exemple-crire-des-donn-es-entr-es-par-l-utilisateur-dans-un-fichier"   >Exemple : &eacute;crire des donn&eacute;es entr&eacute;es par l'utilisateur dans un fichier</h2><p id="67b42d21_3821">La fonction suivante demande des entr&eacute;es &agrave; l'utilisateur et &eacute;crit ces entr&eacute;es dans un fichier <span class="emphasis" id="67b42d21_3822">CSV</span> en utilisant les op&eacute;rations d'E/S de fichiers de la biblioth&egrave;que standard.</p><div class="code-block" data-lang="go"         >
func section2b() {
	nAttempts := 3
	// demander le nom du fichier
	fmt.Println(&quot;Nom du fichier dans lequel enregistrer les donn&eacute;es : &quot;)
	filename, err := ReadNonEmptyLine(nAttempts)
	if err != nil {
		log.Fatalf(&quot;Impossible de lire le nom du fichier : %s&quot;, err)
	}

	// ouvrir le fichier
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf(&quot;Impossible d'ouvrir le fichier : %s&quot;, err)
	}
	defer file.Close()

	done := false
	for !done {
		// lire le nom
		fmt.Print(&quot;Veuillez entrer votre nom : &quot;)
		name, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire le nom : %s&quot;, err)
		} else {
			// s'il n'y a pas d'erreur, lire l'&acirc;ge
			fmt.Print(&quot;Veuillez entrer votre &acirc;ge : &quot;)
			age, err := ReadInt(nAttempts)
			if err != nil {
				log.Printf(&quot;Impossible de lire l'&acirc;ge : %s&quot;, err)
			} else {
				// s'il n'y a pas d'erreur
				line := fmt.Sprintf(&quot;%s,%d\n&quot;, name, age)
				_, err = file.WriteString(line)
				if err != nil {
					log.Fatalf(&quot;Impossible d'&eacute;crire dans le fichier : %s&quot;, err)
				}
			}
		}

		// continuer ou non ?
		fmt.Println(&quot;Voulez-vous entrer continuer (O/N) ?&quot;)
		continueInput, err := ReadNonEmptyLine(nAttempts)
		if err != nil {
			log.Printf(&quot;Impossible de lire la r&eacute;ponse : %s&quot;, err)
		} else {
			if strings.ToUpper(continueInput) == &quot;N&quot; {
				done = true
			}
		}
	}
}
</div><p id="67b42d21_3824">Voici un pas &agrave; pas de la fonction <code class="code" id="67b42d21_3825">section2b</code>:</p><ol class="list _decimal" id="67b42d21_3826" type="1"><li class="list__item" id="67b42d21_3827"><p>La fonction <code class="code" id="67b42d21_3828">section2b</code> commence par d&eacute;clarer une variable <code class="code" id="67b42d21_3829">nAttempts</code> qui d&eacute;finit une limite au nombre de tentatives de lecture des entr&eacute;es.</p></li><li class="list__item" id="67b42d21_3830"><p>Elle demande &agrave; l'utilisateur de saisir le nom du fichier dans lequel les donn&eacute;es doivent &ecirc;tre enregistr&eacute;es. Ceci est fait via l'appel &agrave; <code class="code" id="67b42d21_3831">ReadNonEmptyLine(nAttempts)</code>. Si le nom du fichier est lu avec succ&egrave;s (non vide et pas d'erreur de lecture), il continue, sinon il quitte le programme en enregistrant l'erreur fatale.</p></li><li class="list__item" id="67b42d21_3832"><p>Ensuite, elle tente de cr&eacute;er le fichier sp&eacute;cifi&eacute; &agrave; l'aide de <code class="code" id="67b42d21_3833">os.Create(filename)</code>. Si une erreur se produit pendant la cr&eacute;ation du fichier, une erreur fatale est enregistr&eacute;e et le programme quitte. La fermeture du fichier est report&eacute; apr&egrave;s que toutes les op&eacute;rations suivantes ont &eacute;t&eacute; termin&eacute;es.</p></li><li class="list__item" id="67b42d21_3834"><p>Elle entre ensuite dans une boucle qui continue jusqu'&agrave; ce que <code class="code" id="67b42d21_3835">done</code> devienne vraie.</p></li><li class="list__item" id="67b42d21_3836"><p>Dans la boucle, elle demande d'abord &agrave; l'utilisateur d'entrer son nom, en utilisant une v&eacute;rification des erreurs similaire &agrave; l'entr&eacute;e pr&eacute;c&eacute;dente. Si le nom est lu avec succ&egrave;s, elle demande ensuite l'&acirc;ge &agrave; l'aide de la fonction <code class="code" id="67b42d21_3837">ReadInt(nAttempts)</code>. Sinon, elle enregistre l'erreur et r&eacute;p&egrave;te la boucle.</p></li><li class="list__item" id="67b42d21_3838"><p>S'il n'y a pas d'erreur lors de la lecture de l'&acirc;ge, elle formate le nom et l'&acirc;ge en une cha&icirc;ne avec <code class="code" id="67b42d21_3839">fmt.Sprintf</code>, puis tente d'&eacute;crire cette cha&icirc;ne dans le fichier ouvert &agrave; l'aide de <code class="code" id="67b42d21_3840">file.WriteString(line)</code>. Elle v&eacute;rifie les erreurs lors de l'op&eacute;ration d'&eacute;criture, enregistre l'erreur fatale et quitte si n&eacute;cessaire.</p></li><li class="list__item" id="67b42d21_3841"><p>Ensuite, elle demande &agrave; l'utilisateur s'il souhaite continuer &agrave; entrer plus de donn&eacute;es. Si l'utilisateur saisit <code class="code" id="67b42d21_3842">'N'</code> ou <code class="code" id="67b42d21_3843">'n'</code>, elle change <code class="code" id="67b42d21_3844">done</code> &agrave; <code class="code" id="67b42d21_3845">true</code> ce qui brisera la boucle, sinon elle retourne &agrave; la demande du nom et de l'&acirc;ge.</p></li></ol><p id="67b42d21_3846"><span class="control" id="67b42d21_3847">Note</span>: le paquet <code class="code" id="67b42d21_3848">encoding/csv</code> offre une meilleure interface pour lire et &eacute;crire des fichiers <span class="emphasis" id="67b42d21_3849">CSV</span>. L'exemple pr&eacute;c&eacute;dent &eacute;crit du texte directement dans le fichier. <code class="code" id="67b42d21_3850">encoding/csv</code> permet de lire et d'&eacute;crire plus efficacement. Deux fonctions qui utilisent <code class="code" id="67b42d21_3851">encoding/csv</code> suivent. La premi&egrave;re lit un fichier <span class="emphasis" id="67b42d21_3852">CSV</span>, et l'autre &eacute;crit dans un fichier <span class="emphasis" id="67b42d21_3853">CSV</span>.</p><div class="code-block" data-lang="go"         >
func readCSVFile() {
	f, err := os.Open(&quot;abc.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	reader := csv.NewReader(f)
	records, err := reader.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	for _, record := range records {
		fmt.Println(record) // record est une tranche de cha&icirc;nes de 
		                    // caract&egrave;res repr&eacute;sentant les lignes du fichier
	}
}

func writeCSVFile() {
	f, err := os.Create(&quot;def.csv&quot;)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	writer := csv.NewWriter(f)
	data := []string{&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;}

	if err := writer.Write(data); err != nil {
		log.Fatal(err)
	}
	writer.Flush()

	if err := writer.Error(); err != nil {
		log.Fatal(err)
	}
}
</div></section><div class="last-modified"> Last modified: 12 janvier 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="ch04s01-section-1-lire-le-contenu-d-un-fichier.html">Section 1 : Lire le contenu d&apos;un fichier</a>   <a class="navigation-links__next" href="ch04s03-section-3-copier-un-fichier.html">Section 3 : Copier un fichier en ajoutant des num&eacute;ros de ligne</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>